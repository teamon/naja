package naja.compiler

import treehugger.forest._
// import definitions._
import treehugger.forest.treehuggerDSL._

object Generator {
  case class Config(
    defaultTagName: String
  )

  val defaultConfig = Config(
    defaultTagName = "div"
  )

  def apply(template: Template, config: Config = defaultConfig) = {
    val gen = new Generator(config)
    gen(template)
  }
}

class Generator(config: Generator.Config){
  def apply(template: Template) = {
    val tree = sumTree(template.body.map(e => generate(translate(e))))

    val res = """
    |// Source generated by naja
    |
    |object tpl {
    |  def apply%s = {
    |    %s
    |  }
    |}
    """.stripMargin.format(template.signature, treeToString(tree))
    res
  }

  def sumTree(list: List[Tree]) = list.reduceLeft(_ INFIX("+") APPLY _)

  def translate(node: Node): Expr = node.content match {
    case el @ Tag(_, _, _, _, _, _, _) => el.copy(body = node.body.map(translate))
    case el @ LiteralText(_) => el // TODO: Raise error if there is body present!
  }

  def generate(expr: Expr): Tree = expr match {
    case Tag(name, id, classes, attrs, autoclose, content, body) =>
      // TODO: if(content.isDefined && !body.isEmpty) throw Exception("Tag can't have both content and body")
      // TODO: if(autoclose && (content.isDefined || !body.isEmpty)) throw Exception("Autoclosed tag can't have content nor body")

      val tagName = name getOrElse config.defaultTagName
      val bodyTree = body.map(generate)

      sumTree(
        LIT("<" + tagName + ">") ::
        content.map(generate).toList :::
        bodyTree :::
        LIT("</" + tagName + ">") ::
        Nil
      )

      // openTag + closeTag


      // val attrs1 = id.map { v => Map("id" -> LiteralText(v)) } getOrElse Map()
      // val attrs2 = attrs1 ++ (attributesOpt.map {
      //   _.foldLeft(Map[String, Expr]()) { case (map, key ~ value) => map + (key -> value) }
      // } getOrElse Map())
      // val attrs3 = (attrs2.get("class").map(classes.::) getOrElse classes) match {
      //   case Nil => attrs2
      //   case xs => attrs2 + ("class" -> LiteralText(xs.mkString(" ")))
      // }
      // Tag(name, attrs1 ++ attrs2, autoclose.isDefined)


    case LiteralText(text) => LIT(text)
  }

  // protected def generateAttributes(attributes: Map[String, Expr]) = {
  //   attributes.mapValues(generate)
  // }
}

object TestRun {
  def main(args: Array[String]): Unit = {
    import HamlParser._

    val in = """
    |@(a: Int)
    |
    |%span#foo.bar
    |  %ul
    |    %li Item 1
    |    %li Item 2
    """.stripMargin

    println(in)

    HamlParser(in) match {
      case Success(tpl, _) =>
        val source = Generator(tpl)
        println(source)
      case Failure(msg, _)  => println(msg)
    }
  }
}
